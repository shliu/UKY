#include "mesh.h"

#include <cassert>
#include <iostream>

#include <QFile>
#include <QDomDocument>
#include <QXmlSchema>
#include <QXmlSchemaValidator>

#include "shapefactory.h"

Mesh::Mesh(const QString& filename) {
  assert(filename.length()>0);
  
  // get schema from resource file
  QFile schema_file(":/xsd/mesh.xsd");
  if (!schema_file.open(QIODevice::ReadOnly))
    throw Exception("Could not open mesh schema file");
  QXmlSchema schema;
  schema.load(&schema_file,QUrl::fromLocalFile(schema_file.fileName()));
  if(!schema.isValid()){
    schema_file.close();
    throw Exception("Mesh XML schema definition is invalid");
  }
  schema_file.close();
  
  // schema is valid, verify the instance document
  QFile file(filename);
  if (!file.open(QIODevice::ReadOnly))
    throw Exception("Could not open mesh file");
  QXmlSchemaValidator validator(schema);
  if(!validator.validate(&file, QUrl::fromLocalFile(file.fileName()))){
    file.close();
    throw Exception("XML file is invalid according to schema");
  }
  
  // document is valid, parse and construct DOM tree
  file.reset();
  QDomDocument doc("mesh");
  if (!doc.setContent(&file)) {
    file.close();
    throw Exception("Error parsing address file");
  }
  file.close();
  
  // document has been read successfully - instantiate factory
  ShapeFactory* factory=ShapeFactory::instance();
  
  // get list of all shapes
  QDomElement docElem = doc.documentElement();
  
  // iterate over all first-level elements (i.e. shapes) in the DOM tree
  QDomNode n = docElem.firstChild();
  while(!n.isNull()) {
    // convert the node to an element
    QDomElement e = n.toElement(); 
    assert(!e.isNull());
    
    // the element now holds a DOM subtree representing a shape
    // create shape object from subtree
    Shape* s = factory->createShape(e);
    assert(s!=0);
    
    m_shapes.push_back(s);
    
    n = n.nextSibling();
  }
}

Mesh::~Mesh() {
  // the mesh took ownership of the shapes generated by the factory
  // this means the shapes must be properly deleted when the mesh is destroyed
  for(size_t i=0; i<m_shapes.size(); ++i)
    delete(m_shapes[i]);
}

void Mesh::process() const {
  // compute total area and output some statistics
  double area = 0.0;
  for(size_t i=0; i<m_shapes.size(); ++i)
    area += m_shapes[i]->area();
  std::cout << "Processed " << m_shapes.size() << " elements.\n";
  std::cout << "Total area: " << area << std::endl;
}